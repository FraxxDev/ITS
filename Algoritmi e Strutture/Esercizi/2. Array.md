### Esercizio 1. Analisi lista spese
**Scenario:** Dati N importi, calcolare il totale e la spesa max nell'array.

```python
INIZIO
	n <- 0
	# Chiedo quanti scontrini devo analizzare
	LEGGI n
	# Creo una lista (array) vuota di dimensione n
	array <- [n]
	totale <- 0
	piu_costoso <- 0
	
	# Ciclo per leggere tutti i valori uno a uno
	PER i DA 0 A n-1
		LEGGI array [i]
		
		# Controllo se quello attuale è il più caro visto finora
		SE array[i] > piu_costoso
			piu_costoso <- array[i]
			
		# Aggiungo al totale generale
		totale <- totale + array[i]
	
	SCRIVI piu_costoso
	SCRIVI totale
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[Init array, totale=0, piu_costoso=0]
		C --> D[i <- 0]
	end
	
	subgraph Logica
		D --> E{i < n}
		
		E -- Vero --> F[LEGGI array di i]
		F --> G{array di i > piu_costoso}
		
		G -- Vero --> H[piu_costoso <- array di i]
		G -- Falso --> I
		H --> I
		
		I --> J[totale <- totale + array di i]
		J --> K[i <- i + 1]
		K --> E
		
		E -- Falso --> L[SCRIVI piu_costoso]
		L --> M[SCRIVI totale]
	end
	
	M --> N[Fine]
```

### Esercizio 2. Somma dei valori positivi
**Scenario:** Dato un array di n numeri, calcolare somma solo dei positivi.

```python
INIZIO
	somma <- 0
	n <- 0
	LEGGI n
	# Creo l'array
	array <- [n]
	
	# Scorro tutto l'array dall'inizio alla fine
	PER i DA 0 A n-1
		 # Chiedo il numero
		 LEGGI array[i]
		 
		 # Se il numero è positivo (>0), lo sommo. Se è negativo lo ignoro.
		 SE array[i] > 0
			 somma <- somma + array[i]
			 
	STAMPA somma
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[somma <- 0]
		C --> D[i <- 0]
	end
	
	subgraph Logica
		D --> E{i < n}
		
		E -- Vero --> F[LEGGI array di i]
		F --> G{array di i > 0}
		
		G -- Vero --> H[somma <- somma + array di i]
		G -- Falso --> I
		
		H --> I[i <- i + 1]
		I --> E
		
		E -- Falso --> J[STAMPA somma]
	end
	
	J --> K[Fine]
```

---

### Esercizio 3. Conteggio valori sopra la media
**Scenario:** Calcola media array e conta quanti sono maggiori della media.

```python
INIZIO
	n <- 0
	LEGGI n
	array <- [n]
	somma <- 0
	
	# FASE 1: Caricamento e Somma
	PER i DA 0 A n-1
		LEGGI array[i]
		# Faccio subito la somma mentre leggo
		somma <- somma + array[i]
	
	# Calcolo la media matematica
	media <- somma / n
	SCRIVI media
	
	n_maggiori_media <- 0
	
	# FASE 2: Conteggio
	# Rileggo l'array per vedere chi supera la media
	PER i DA 0 A n-1
		SE array[i] > media
			n_maggiori_media <- n_maggiori_media + 1
			
	SCRIVI n_maggiori_media
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[somma <- 0]
	end
	
	subgraph Logica
		C --> D[Ciclo 1: Leggi array e calcola somma]
		D --> E[media <- somma / n]
		E --> F[SCRIVI media]
		
		F --> G[n_maggiori <- 0]
		G --> H[i <- 0]
		
		H --> I{i < n}
		I -- Vero --> J{array di i > media}
		
		J -- Vero --> K[n_maggiori <- n_maggiori + 1]
		J -- Falso --> L
		
		K --> L[i <- i + 1]
		L --> I
		
		I -- Falso --> M[SCRIVI n_maggiori]
	end
	
	M --> N[Fine]
```

---

### Esercizio 4. Verifica array ordinato
**Scenario:** Stabilire se l’array è ordinato in modo crescente.

```python
INIZIO
	n <- 0
	LEGGI n
	array <- [n]
	# Parto ottimista: assumo che sia ordinato (true)
	ordinato <- true
	
	# Carico tutti i numeri nell'array
	PER i da 0 A n-1
		LEGGI array[i]
	
	# Controllo l'ordinamento (fino al penultimo elemento)
	PER i DA 0 A n-2
		# Se trovo un numero più grande del suo successivo, l'ordine è rotto
		SE array[i] > array[i+1]
			ordinato <- false
			ESCI DAL CICLO # Inutile continuare a controllare
			
	SE ordinato
		SCRIVI "ordinato"
	ALTRIMENTI
		SCRIVI "non ordinato"
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[Ciclo 1: Caricamento Array]
		C --> D[ordinato <- true]
		D --> E[i <- 0]
	end
	
	subgraph Logica
		E --> F{i < n-1}
		
		F -- Vero --> G{array di i > array di i+1}
		
		G -- Vero --> H[ordinato <- false]
		H --> I[ESCI DAL CICLO]
		
		G -- Falso --> J[i <- i + 1]
		J --> F
		
		F -- Falso --> I
		
		I --> K{ordinato == true}
		K -- Vero --> L[SCRIVI 'ordinato']
		K -- Falso --> M[SCRIVI 'non ordinato']
	end
	
	L --> N[Fine]
	M --> N
```

---

### Esercizio 5. Ricerca elemento più frequente
**Scenario:** Trova valore più frequente e numero di occorrenze.

```python
INIZIO
	n <- 0
	LEGGI n
	array <- [n]
	frequenza_valore <- 0 # Record di quante volte ho visto il vincitore
	
	# Carico l'array
	PER i DA 0 A n-1
		LEGGI array[i]
		
	valore_piu_presente <- array[0]
	
	# Ciclo Esterno: Prendo un numero alla volta (il "candidato")
	PER i DA 0 A n-1
	contatore <- 0
		# Ciclo Interno: Confronto il candidato con tutti gli altri
		PER j DA 0 A n-1
			SE array[i] == array[j]
				contatore <- contatore + 1
		
		# Se il candidato attuale ha battuto il record precedente
		SE contatore > frequenza_valore
			frequenza_valore <- contatore
			valore_piu_presente <- array[i]
			
	SCRIVI valore_piu_presente
	SCRIVI frequenza_valore
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[Carica Array]
		C --> D[frequenza_valore <- 0]
	end
	
	subgraph Logica
		D --> E[Ciclo Esterno i: scorre elementi]
		E --> F[contatore <- 0]
		
		F --> G[Ciclo Interno j: conta occorrenze]
		G --> H{contatore > frequenza_valore}
		
		H -- Vero --> I[Aggiorna frequenza_valore e valore_piu_presente]
		H -- Falso --> J
		
		I --> J[Fine Ciclo Esterno]
		J --> K{Tutti controllati?}
		K -- No --> E
		
		K -- Si --> L[SCRIVI valore_piu_presente]
		L --> M[SCRIVI frequenza_valore]
	end
	
	M --> N[Fine]
```

---

### Esercizio 6. Confronto due array
**Scenario:** Conta quante posizioni corrispondenti sono uguali tra Array A e B.

```python
INIZIO
	n <- 0
	LEGGI n
	arrayA <- [n]
	arrayB <- [n]
	contatore_uguali <- 0
	
	# Riempio il primo array
	PER i DA 0 A n-1
		LEGGI arrayA[i]
		
	# Riempio il secondo array
	PER i DA 0 A n-1
		LEGGI arrayB[i]
	
	# Confronto posizione per posizione (indice i)
	PER i DA 0 A n-1
		# Se l'elemento nella casella i di A è uguale a quello in B
		SE arrayA[i] == arrayB[i]
			contatore_uguali <- contatore_uguali + 1
	
	SCRIVI contatore_uguali
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n]
		B --> C[Ciclo: Carica Array A]
		C --> D[Ciclo: Carica Array B]
		D --> E[contatore_uguali <- 0]
		E --> F[i <- 0]
	end
	
	subgraph Logica
		F --> G{i < n}
		
		G -- Vero --> H{arrayA di i == arrayB di i}
		H -- Vero --> I[contatore_uguali <- contatore_uguali + 1]
		H -- Falso --> J
		
		I --> J[i <- i + 1]
		J --> G
		
		G -- Falso --> K[SCRIVI contatore_uguali]
	end
	
	K --> L[Fine]
```
