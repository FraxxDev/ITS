### Esercizio 1. Inserimento e Stampa
**Scenario:** Inserimento di n elementi all'interno di una lista chiamata L. Decido di stampare gli elementi nell'ordine di inserimento.

```python
 INIZIO
	# Creo una lista vuota pronta a ricevere dati
	L <- Lista Vuota
	
	n <- 0
	# Chiedo all'utente quanti numeri vuole inserire
	LEGGI n
	valore <- 0
	
	# CICLO DI INSERIMENTO
	# Ripeto per n volte
	PER i da 0 a n-1
		LEGGI valore
		# Aggiungo il valore in coda alla lista
		AGGIUNGI(L, valore)
		
	# CICLO DI STAMPA
	# Scorro la lista dalla posizione 0 fino all'ultima
	PER i da 0 a lunghezza(L)-1
		# Stampo l'elemento che si trova all'indice i
		SCRIVI L[i]
 FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[L <- Lista Vuota]
		B --> C[LEGGI n]
	end
	
	subgraph Logica
		C --> D[i <- 0]
		
		D --> E{i < n}
		E -- Vero --> F[LEGGI valore]
		F --> G[AGGIUNGI valore a L]
		G --> H[i <- i + 1]
		H --> E
		
		E -- Falso --> I[i <- 0]
		
		I --> J{i < lunghezza L}
		J -- Vero --> K[SCRIVI L di i]
		K --> L[i <- i + 1]
		L --> J
	end
	
	J -- Falso --> M[Fine]
```

---

### Esercizio 2. Somma e Media
**Scenario:** Leggi n numeri, aggiungili ad L, calcola la somma e la media.

```python
INIZIO
	L <- Lista Vuota
	
	somma <- 0
	media <- 0
	
	valore <- 0
	n <- 0
	LEGGI n
	
	# Mentre riempio la lista, calcolo già la somma per risparmiare tempo
	PER i da 0 a n-1
		LEGGI valore
		AGGIUNGI(L, valore)
		# Accumulo il valore nella variabile somma
		somma <- somma + valore
	
	# Calcolo la media matematica (Totale / Numero Elementi)
	media <- somma / lunghezza(L)
	
	# Stampo i risultati finali
	SCRIVI somma
	SCRIVI media
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[L <- Lista Vuota]
		B --> C[somma <- 0]
		C --> D[LEGGI n]
	end
	
	subgraph Logica
		D --> E[i <- 0]
		
		E --> F{i < n}
		
		F -- Vero --> G[LEGGI valore]
		G --> H[AGGIUNGI valore a L]
		H --> I[somma <- somma + valore]
		I --> L[i <- i + 1]
		L --> F
		
		F -- Falso --> M[media <- somma / lunghezza L]
		M --> N[SCRIVI somma]
		N --> O[SCRIVI media]
	end
	
	O --> P[Fine]
```

---

### Esercizio 3. Conteggio positivi, negativi e zeri
**Scenario:** Aggiungere n elementi ad una lista e definire quanti sono positivi, quanti negativi e quanti zeri.

```python
INIZIO
	L <- Lista Vuota
	
	# Preparo tre contatori distinti
	totalePos <- 0
	totaleNeg <- 0
	totaleZero <- 0
	
	valore <- 0
	n <- 0
	LEGGI n
	
	# Fase 1: Riempio la lista con tutti i numeri
	PER i da 0 a n-1
		LEGGI valore
		AGGIUNGI(L, valore)
		
	# Fase 2: Controllo ogni numero per vedere com'è
	PER i da 0 a lunghezza(L)-1
		# Se è maggiore di zero...
		SE L[i] > 0
			totalePos <- totalePos + 1
		# ...altrimenti, se è minore di zero...
		ALTRIMENTI SE L[i] < 0
			totaleNeg <- totaleNeg + 1
		# ...altrimenti deve per forza essere zero
		ALTRIMENTI
			totaleZero <- totaleZero + 1
			
	# Stampo il resoconto finale
	SCRIVI totalePos
	SCRIVI totaleNeg
	SCRIVI totaleZero
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[Init Contatori a 0]
		B --> C[Riempimento Lista L]
	end
	
	subgraph Logica
		C --> D[i <- 0]
		D --> E{i < lunghezza L}
		
		E -- Vero --> F{L di i > 0}
		
		F -- Vero --> G[totalePos++]
		F -- Falso --> H{L di i < 0}
		
		H -- Vero --> I[totaleNeg++]
		H -- Falso --> J[totaleZero++]
		
		G --> K[i <- i + 1]
		I --> K
		J --> K
		
		K --> E
		
		E -- Falso --> L[SCRIVI risultati]
	end
	
	L --> M[Fine]
```

---

### Esercizio 4. Eliminazione occorrenze
**Scenario:** Popolate una lista. Leggete un valore x ed eliminate tutte le occorrenze di questo valore x dalla lista. Stampate la lista aggiornata.

```python
INIZIO
	L <- Lista Vuota
	
	valoreDaEliminare <- 0
	valoreLista <- 0
	
	n <- 0
	LEGGI n
	
	# Riempio la lista
	PER i da 0 a n-1
		LEGGI valoreLista
		AGGIUNGI(L, valoreLista)
	
	LEGGI valoreDaEliminare	
	
	# Resetto l'indice per scorrere la lista dall'inizio
	i <- 0
	
	# Uso MENTRE perché la lunghezza della lista cambierà se elimino cose.
	# Controllo fino alla fine della lista attuale.
	MENTRE i < lunghezza(L)
		SE L[i] == valoreDaEliminare
			# Rimuovo l'elemento. La lista si accorcia e gli elementi successivi scalano indietro.
			# NON incremento 'i' perché devo controllare il nuovo elemento che ha preso questo posto.
			rimuovi(L, i)
		ALTRIMENTI
			# Se il numero va bene, passo al prossimo indice
			i <- i + 1
	
	# Stampo la lista pulita
	PER i da 0 a lunghezza(L)-1
		SCRIVI L[i]
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[Popola Lista L]
		B --> C[LEGGI valoreDaEliminare]
		C --> D[i <- 0]
	end
	
	subgraph Logica
		D --> E{i < lunghezza L}
		
		E -- Vero --> F{L di i == valoreDaEliminare}
		
		F -- Vero --> G[rimuovi L alla pos i]
		G --> E
		
		F -- Falso --> H[i <- i + 1]
		H --> E
		
		E -- Falso --> I[Stampa Lista Aggiornata]
	end
	
	I --> J[Fine]
```

---

### Esercizio 5. Inserimento ordinato
**Scenario:** Inserire un nuovo valore in una lista già ordinata mantenendo l'ordine e stampare l'indice di inserimento.

```python
INIZIO
	# Immaginiamo che L sia già piena e ordinata (es: 2, 5, 8)
	L <- Lista Popolata In Ordine Crescente
	
	nuovaPosizione <- 0
	# Variabile 'bandiera' per sapere se abbiamo trovato il posto
	inserito <- false
	
	valoreNumerico <- 0
	LEGGI valoreNumerico
	
	# Scorro la lista per cercare il primo numero più grande del mio
	PER i da 0 a lunghezza(L)-1
		SE L[i] > valoreNumerico
			# Trovato! Inserisco il mio numero PRIMA di quello più grande
			INSERISCI(L, valoreNumerico, i)
			nuovaPosizione <- i
			# Mi segno che l'ho inserito
			inserito <- true
			# Esco subito dal ciclo, ho finito
			esci dal ciclo
			
	# Se ho finito il ciclo e non l'ho ancora inserito, vuol dire che
	# il mio numero è il più grande di tutti.
	SE inserito == false
		AGGIUNGI(L, valoreNumerico) # Lo metto in fondo
		nuovaPosizione <- lunghezza(L)-1
	
	SCRIVI "Posizione del numero inserito: ", nuovaPosizione
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[L già popolata]
		B --> C[inserito <- false]
		C --> D[LEGGI valoreNumerico]
	end
	
	subgraph Logica
		D --> E[i <- 0]
		E --> F{i < lunghezza L}
		
		F -- Vero --> G{L di i > valoreNumerico}
		
		G -- Vero --> H[INSERISCI valore a pos i]
		H --> I[nuovaPosizione <- i]
		I --> J[inserito <- true]
		J --> K[ESCI DAL CICLO]
		
		G -- Falso --> L[i <- i + 1]
		L --> F
		
		F -- Falso --> M
		K --> M
		
		M --> N{inserito == false}
		N -- Vero --> O[AGGIUNGI valore in fondo]
		O --> P[nuovaPosizione <- Ultimo Indice]
		N -- Falso --> Q
		P --> Q
		
		Q --> R[SCRIVI nuovaPosizione]
	end
	
	R --> S[Fine]
```

---

### Esercizio 6. Concatenazione Liste
**Scenario:** Unione di 2 liste. Dati gli elementi di L1 ed L2, voglio popolare L3 con tutti gli elementi.

```python
INIZIO
	L1 <- Lista Vuota
	L2 <- Lista Vuota
	L3 <- Lista Vuota
	L4 <- Lista Vuota
	
	valore <- 0
	n <- 0
	m <- 0
	
	# RIEMPIMENTO LISTA 1
	LEGGI n
	PER i da 0 a n-1
		LEGGI valore
		AGGIUNGI(L1, valore)
		
	# RIEMPIMENTO LISTA 2
	LEGGI m
	PER i da 0 a m-1
		LEGGI valore
		AGGIUNGI(L2, valore)
		
	# COSTRUZIONE LISTA 3 (L1 + L2)
	# Copio prima tutti gli elementi di L1
	PER i da 0 a lunghezza(L1)-1
		AGGIUNGI(L3, L1[i])
		
	# Copio poi tutti gli elementi di L2
	PER i da 0 a lunghezza(L2)-1
		AGGIUNGI(L3, L2[i])
		
	# COSTRUZIONE LISTA 4 (L2 + L1) - Esempio inverso
	# Copio prima L2
	PER i da 0 a lunghezza(L2)-1
		AGGIUNGI(L4, L2[i])
	
	# Poi copio L1
	PER i da 0 a lunghezza(L1)-1
		AGGIUNGI(L4, L1[i])
FINE
```

```mermaid
graph TD
	subgraph Setup
		A[Inizio] --> B[LEGGI n e m]
		B --> C[Popola L1 con n elementi]
		C --> D[Popola L2 con m elementi]
	end
	
	subgraph Logica
		D --> E[i <- 0]
		E --> F{i < len L1}
		F -- Vero --> G[AGGIUNGI L1 di i su L3]
		G --> H[i++]
		H --> F
		
		F -- Falso --> I[i <- 0]
		I --> J{i < len L2}
		J -- Vero --> K[AGGIUNGI L2 di i su L3]
		K --> L[i++]
		L --> J
		
		J -- Falso --> M[Logica inversa per L4]
	end
	
	M --> N[Fine]
```
